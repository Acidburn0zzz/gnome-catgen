#!/usr/bin/env bash

#
# gnome-catgen | A Gnome 3.12 and 3.14 application-overview folder configuration tool
#
# Written by Kevin MacMartin
# Released under the MIT license
#

system_apps_dir='/usr/share/applications'
local_apps_dir="$HOME/.local/share/applications"

gnome_catpath="$local_apps_dir-categories"
script_name="${0//*\/}"

# If $EDITOR isn't set, use vi
[[ -z "$EDITOR" ]] \
    && EDITOR=vi

# Colour definitions if not run in a pipe
[[ -t 1 ]] && {
    c_grey='\e[1;30m'    # DARK GREY
    c_red='\e[1;31m'     # RED
    c_green='\e[1;32m'   # GREEN
    c_yellow='\e[1;33m'  # YELLOW
    c_blue='\e[1;34m'    # BLUE
    c_magenta='\e[1;35m' # MAGENTA
    c_cyan='\e[1;36m'    # CYAN
    c_white='\e[1;37m'   # WHITE
    c_clear='\e[0m'      # DISABLES COLOUR
    text_newline='\n'    # NEW LINE
    text_comma=','       # COMMA
}

# Takes a list of items and prints them stylishly in a terminal and as a list when piped
function list_apps() {
    # Set $array to the passed values and exit if only the title exists
    array=(${@})
    [[ ${#array[*]} = 0 ]] \
        && return 1

    # Run the following if not in a pipe and the tput command exists, otherwise fallback to an unformatted list
    [[ -t 1 ]] && [[ $(type -P tput) ]] && {
        # Find the column width (the length of the longest item name + 1 for spacing)
        colwidth=0
        for item in ${array[@]}; do
            [[ $(wc -c <<< "$item") -gt $colwidth ]] \
                && colwidth=$(( $(wc -c <<< "$item") - 1))
        done
        colwidth=$(( $colwidth + 3 ))

        # Find the number of items that can be squeezed on a single line
        array_per_line=1
        while [ $(( $(( $array_per_line + 1 )) * $colwidth)) -lt $(( $(tput cols) - 2 )) ]; do
            array_per_line=$(( $array_per_line + 1 ))
        done
        while [ $(( $array_per_line * $colwidth )) -lt $(( $(tput cols) - 2 )) ]; do
            colwidth=$(( $colwidth + 1 ))
        done
        colwidth=$(( $colwidth - 3 ))

        # Print the list
        printf " "
        count=0 ; for item in ${array[@]}; do
            leftgap=$(( $(( $colwidth - $(wc -c <<< "$item") )) / 2 ))
            rightgap=$(( $(( $colwidth - $(wc -c <<< "$item") )) - $leftgap ))
            [[ $count -ge $array_per_line ]] && {
                count=0
                printf '\n '
            }
            [[ ! $count = 0 ]] \
                && printf " $c_grey|$c_clear "
            printf "$c_white%s$c_grey%s$c_clear%${leftgap}s%${rightgap}s" "$(sed 's|\.desktop||' <<< $item)" '.desktop' '' ''
            count=$(expr $count + 1)
        done
        printf '\n'
    } || {
        # Display all items as an unformatted, space-separated list
        for item in ${array[@]}; do
            printf '%s ' "$item"
        done
    }
}

# Gets the list of folders based on the dconf configuration
function getfolders() {
    eval echo -e $(gsettings get org.gnome.desktop.app-folders folder-children \
        | sed 's|^@as \[\]|None|g' \
        | sed "s|^\[['\"]||g;s|['\"]\]$||g;s|['\"]\ *,\ *['\"]|,\ |g" \
        | sed -re "s|\\\([\"\\\])|\1|g" \
        | sed 's|^|\${c_blue}|g;s|$|\$c_clear|;s|, |\$c_white$text_comma \${c_blue}|g')
}

# Gets the list of folders based on *.category
function _getfolders() {
    for cat in "$gnome_catpath"/*.category; do
        [[ -n "$(cat "$cat" | grep -v -e '^ *#')" ]] \
            && echo "$cat"
    done | sed 's|^.*\/||g;s/.category$//g'
}

function getapps() {
    echo -ne "$text_newline"
    while read -r cat; do
        [[ ! "$cat" = "@as" ]] && {
            echo -ne "$c_blue$cat$c_white:$c_clear $text_newline"
            ARRAY=( $(gsettings get org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/$cat/ apps \
                | grep -v "@as \[\]" \
                | sed "s|^\[['\"]||g;s|['\"]\]$||g;s|['\"]\ *,\ *['\"]|\n|g" \
                | sed -re "s|\\\([\"\\\])|\1|g") )
            list_apps ${ARRAY[@]}
        }
        echo
    done < <(gsettings get org.gnome.desktop.app-folders folder-children \
        | sed "s/\[//g;s/\]//g;s/^['\"]//g;s/['\"]$//g;s/['\"],\ *['\"]/\n/g" \
        | sed -re "s|\\\([\"\\\])|\1|g")
}

function getremaining() {
    # Fail if the config directory is read only or doesn't exist
    [[ ! -w "$gnome_catpath" ]] && {
        echo -e "\n${c_red}ERROR$c_clear: Config folder '$gnome_catpath' either doesn't exist or isn't writable" 2>&1
        exit 1
    }

    # Create a list of all the applications that don't have NoDisplay=true or Hidden=true
    applist=$(grep -L -i -E "(nodisplay|hidden)\ *=\ *true" "$system_apps_dir"/*.desktop "$local_apps_dir"/*.desktop \
        | sed 's|^.*\/||g' \
        | sort -u)

    # Remove $system_apps_dir with duplicates in $local_apps_dir that contain NoDisplay=true or Hidden=true
    while read -r application; do
        applist=$(sed "s|$application\ *||" <<< $applist)
    done < <(grep -l -i -E "(nodisplay|hidden)\ *=\ *true" "$local_apps_dir"/*.desktop \
        | grep -o -e "[^\/]*$" | sort -u)

    # Remove all applications that are defined in gnome-catgen categories
    while read -r application; do
        [[ $(grep -v -e "^ *#" <<< '$application') ]] && [[ -n "$application" ]] \
            && applist="$(sed "s|$application\ *||" <<< $applist)"
    done < <(sed 's|\\|\\\\|g' "$gnome_catpath"/*.category)

    # Output each remaining app
    for application in ${applist[@]}; do
        echo "$application"
    done
}

function set() {
    # Fail if the config directory doesn't exist, otherwise announce initiation
    [[ ! -d "$gnome_catpath" ]] && {
        echo -e "\n${c_red}ERROR$c_clear: config folder '$gnome_catpath' either doesn't exist or isn't readable" 2>&1
        exit 1
    }
    echo -e "\n${c_white}Applying current folder configuration...$c_clear\n"

    # Wipe out any old folder settings
    echo -e "${c_white}Clearing old category data before populating folders...$c_clear"
    dconf reset -f /org/gnome/desktop/app-folders/folders/

    # Create a list of categories to work from using the non-empty .category files
    _categories=$(_getfolders)

    # Start the list of dconf categories, built using the one above
    categories='['

    # Add the app data for each category and output an error if none is defined
    while read -r cat; do
        # Reset the application list
        unset applist

        # Add applications from the category if they exist, are set to display and aren't commented
        echo -e "\n${c_white}Evaluating: $c_blue$cat$c_clear"
        while read -r application; do
            [[ $(grep -v -e "^ *#" <<< '$application') ]] && {
                if [[ -f "$local_apps_dir/$application" ]]; then
                    [[ ! $(grep -i -E "(nodisplay|hidden)\ *=\ *true" "$local_apps_dir/$application") ]] && {
                        [[ -n "$notempty" ]] && application=$(echo -e "\n$application")
                        applist=$applist$application
                        notempty=1
                    }
                elif [[ -f "$system_apps_dir/$application" ]]; then
                    [[ ! $(grep -i -E "(nodisplay|hidden)\ *=\ *true" "$system_apps_dir/$application") ]] && {
                        [[ -n "$notempty" ]] \
                            && application=$(echo -e "\n$application")
                        applist=$applist$application
                        notempty=1
                    }
                fi
            }
        done < <(cat "$gnome_catpath/${cat}.category")
        applist=$(sort -u <<< "$applist")

        # Write the category and its applications if the temp file isn't empty
        [[ -n "$notempty" ]] && {
            # Add $cat to the dconf categories list if it contained any valid apps
            categories="$categories, '$(sed 's|\\|\\\\\\|g'";s|'|\\\'|g" <<< "$cat")'"

            # Write the folder category's name to dconf
            gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/"$cat"/ name "$cat"

            # Get the application list and escape any quotes, then write to dconf
            gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/"$cat"/ apps \
                "$(while read -r application; do
                       [[ $(grep "'" <<< "$application") ]] \
                           && sed 's|"|\\"|g;s|^|"|;s|$|"|' <<< "$application" \
                           || sed "s|^|'|;s|$|'|" <<< "$application"
                   done < <(sed 's|\\|\\\\\\|g' <<< "$applist") \
                       | sed -e ':a;N;$!ba;'"s/\n/, /g" \
                       | sed 's|^|\[|;s|$|\]|')"
        }

        # Free the empty category marker so the next category has to set it again
        unset notempty
    done <<< "$_categories"

    # Finalize the dconf categories list then write to dconf and finish
    categories="$(sed 's|\[, |\[|' <<< $categories)]"
    [[ $(grep -v "\[\]" <<< "$categories") ]] \
        && gsettings set org.gnome.desktop.app-folders folder-children "$categories"
    echo -e "\n${c_green}Done!$c_clear"
}

function chooseremaining() {
    # Fail if the config directory is read only or doesn't exist
    [[ ! -w "$gnome_catpath" ]] && {
        echo -e "\n${c_red}ERROR$c_clear: config folder '$gnome_catpath' either doesn't exist or isn't writable" 2>&1
        exit 1
    }

    # Start if applications without folders exist
    remaining=$(getremaining)
    if [ -n "$remaining" ]; then
        # Cycle through the output of getremaining
        echo -ne "\n${c_white}Folder Categories:\n  "
        getfolders
        echo
        echo -e "${c_white}Enter:\n  ${c_red}Category name $c_grey| ${c_red}Blank to skip $c_grey| ${c_red}Ctrl-c to quit$c_clear\n"
        while read -r app; do
            eval echo -ne "$(sed 's|^|\${c_white}|;s|\.desktop|\${c_grey}\.desktop\${c_clear}|' <<< "$app")"'${c_white}:${c_clear}\ '
            read -r catname </dev/tty
            if [ -n "$catname" ]; then
                changed=1
                echo "$app" >> "$gnome_catpath/${catname}.category"
            else
                echo -e "Skipping $c_white$(sed 's|\.desktop||' <<< $app)${c_grey}.desktop${c_clear}..."
            fi
        done <<< "$remaining"

        # Offer to run the set function if changes were made
        if [ -n "$changed" ]; then
            while [ 0 ]; do
                echo -en "\n${c_white}Update configured folder categories in Gnome? [${c_green}Y$c_white/${c_red}N$c_white]:$c_clear "
                read update_question
                case $update_question in
                    y|Y)
                        set
                        break
                        ;;
                    n|N)
                        break
                        ;;
                    *)
                        echo -e "\n${c_red}ERROR$c_clear: Invalid option" 2>&1
                        ;;
                esac
            done
        else
            echo -e "\n${c_white}Finished without making changes$c_clear\n"
        fi
    else
        echo -e "\n${c_white}No uncategorized applications found$c_clear\n"
    fi
}

function editcategory() {
    if [ -n "$1" ]; then
        echo "Editing ${1}..."
        "$EDITOR" "$gnome_catpath/${1}.category"
    else
        echo -e "\n${c_red}ERROR$c_clear: run with a category name as an argument" 2>&1
        help
        exit 1
    fi
}

function help() {
    # Display help information
    echo -e "\n$c_white$script_name$c_clear: Gnome 3 Folder Category Configuration Tool\n"
    echo -e "${c_blue}SYNOPSIS$c_clear\n  $c_yellow$script_name$c_clear [${c_magenta}COMMAND$c_clear] [${c_magenta}CAT$c_clear]\n"
    echo -e "${c_blue}COMMANDS$c_clear\n  ${c_red}READ$c_clear"
    echo -e "    $c_white-f$c_grey|$c_white--get-folders$c_clear          list active folders"
    echo -e "    $c_white-a$c_grey|$c_white--get-apps$c_clear             list apps in each active folders"
    echo -e "    $c_white-r$c_grey|$c_white--get-remaining$c_clear        list apps without a folder\n"
    echo -e "  ${c_red}EDIT$c_clear"
    echo -e "    $c_white-c$c_grey|$c_white--choose-remaining$c_clear     assign folders to unassigned apps"
    echo -e "    $c_white-e$c_grey|$c_white--edit-category$c_clear [${c_magenta}CAT$c_clear]  edit the .category file for CAT\n"
    echo -e "  ${c_red}WRITE$c_clear"
    echo -e "    $c_white-s$c_grey|$c_white--set$c_clear                  apply current folder configuration"
    echo -e "    $c_white-x$c_grey|$c_white--clear$c_clear                remove applied folder configuration\n"
    echo -e "  ${c_red}INFORMATION$c_clear"
    echo -e "    $c_white-h$c_grey|$c_white--help$c_clear                 display this help\n"
}

# Install the gnome-catgen config folder if it doesn't exist
[[ -d "$gnome_catpath" ]] \
    || install -d "$gnome_catpath"

# Fail if the config directory is read only or doesn't exist
[[ ! -w "$gnome_catpath" ]] && {
    echo -e "\n${c_red}ERROR$c_clear: the config folder @ $gnome_catpath doesn't exist or can't be written to" 2>&1
    exit 1
}

# Parse commandline arguments
if [[ -n "$1" ]]; then
    for param in $@; do
        case "$param" in
            f|-f|--get-folders)
                getfolders
                exit 0
                ;;
            a|-a|--get-apps)
                getapps
                exit 0
                ;;
            r|-r|--get-remaining)
                list_apps $(getremaining)
                exit 0
                ;;
            c|-c|--choose-remaining)
                chooseremaining
                exit 0
                ;;
            e|-e|--edit-category)
                editcategory "$2"
                exit 0
                ;;
            s|-s|--set)
                set
                exit 0
                ;;
            x|-x|--clear)
                gsettings set org.gnome.desktop.app-folders folder-children "[]"
                dconf reset -f /org/gnome/desktop/app-folders/folders/
                exit 0
                ;;
            h|-h|--help)
                help
                exit 0
                ;;
            *)
                echo -e "\n${c_red}ERROR$c_clear: $1 is not a valid option" 2>&1
                help
                exit 1
                ;;
        esac
    done
else
    echo -e "\n${c_red}ERROR$c_clear: run with a valid command as an argument" 2>&1
    help
    exit 1
fi
